<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>ECE 3400 Team 2 Website</title>

  <!-- Bootstrap Core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom Fonts -->
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic" rel="stylesheet" type="text/css">
  <link href="vendor/simple-line-icons/css/simple-line-icons.css" rel="stylesheet">

  <!-- Custom CSS -->
  <link href="css/stylish-portfolio.min.css" rel="stylesheet">

</head>

<body id="page-top">

  <!-- Navigation -->
  <a class="menu-toggle rounded" href="#">
    <i class="fas fa-bars"></i>
  </a>
  <nav id="sidebar-wrapper">
    <ul class="sidebar-nav">
      <li class="sidebar-brand">
        <a class="js-scroll-trigger" href="#">Team 2</a>
      </li>
      <li class="sidebar-nav-item">
        <a class="js-scroll-trigger" href="index.html">Home</a>
      </li>
      <li class="sidebar-nav-item">
        <a class="js-scroll-trigger" href="index.html#Team">Team Members</a>
      </li>
 	<li class="sidebar-nav-item">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> <span class="nav-label">Labs</span><span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        <li><a style="color: #1D809F" href="lab1.html#Lab1">Lab 1</a></li>
                        <li><a style="color: #1D809F" href="lab2.html#Lab2">Lab 2</a></li>
                        <li><a style="color: #1D809F" href="lab3.html#Lab3">Lab 3</a></li>
			    <li><a style="color: #1D809F" href="lab4_milestone4.html#Milestone4">Lab 4</a></li>
                       
                    </ul>
                </li>
	<li class="sidebar-nav-item">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> <span class="nav-label">Milestones</span><span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        <li><a style="color: #1D809F" href="milestones.html#Milestone1">Milestone 1</a></li>
                        <li><a style="color: #1D809F" href="milestone2.html#Milestone2">Milestone 2</a></li>
                        <li><a style="color: #1D809F" href="milestone3.html#Milestone3">Milestone 3</a></li>
                        <li><a style="color: #1D809F" href="lab4_milestone4.html#Milestone4">Milestone 4</a></li>
                    </ul>
                </li>
      <li class="sidebar-nav-item">
        <a class="js-scroll-trigger" href="TEAM CONTRACT.pdf">Team Contract</a>
      </li>
    </ul>
  </nav>

  <!-- Header -->
  <header class="masthead d-flex">
    <div class="container text-center my-auto">
      <h1 class=class="mb-1" style="color: white; text-shadow: 2px 2px 5px black;text-indent: 100px;">Milestones</h1>
      <h3 class=class="mb-1" style="color: white; text-shadow: 2px 2px 5px black;text-indent: 100px;">
        <em> What We Have Accomplished </em>
      </h3>
      <a class="btn btn-primary btn-xl js-scroll-trigger" style="margin-left: 100px" href="#Labs">Start</a>
    </div>
    <div class="overlay"></div>
  </header>

 <!--Create Link within this html file-->
  <!-- Milestone -->
  <section class="content-section bg-primary text-white text-center" id="Labs">
    <div class="container">
      <div class="content-section-heading">
        <h3 class="text-secondary mb-0">Milestones</h3>
        <h2 class="mb-5">What We Have Accomplished :)</h2>
      </div>
      <div class="row">
        <div class="col-lg-3 col-md-6 mb-5 mb-lg-0">
          <span class="service-icon rounded-circle mx-auto mb-3">
   	<a href="milestones.html#Milestone1"><i class="icon-screen-smartphone"></i></a>
          </span>
          <h4><a href="milestones.html#Milestone1" style="color: #FFFFFF">
	<strong  >Milestone 1</strong>
		  </h4></a>
          <p class="text-faded mb-0">Line Following and Figure Eight</p>

        </div>
        <div class="col-lg-3 col-md-6 mb-5 mb-lg-0">
          <span class="service-icon rounded-circle mx-auto mb-3">
          <a href="milestone2.html#Milestone2"><i class="icon-pencil"></i></a>
          </span>
          <h4><a href="milestone2.html#Milestone2" style="color: #FFFFFF">
            <strong  >Milestone 2</strong>
          </h4></a>
          <p class="text-faded mb-0">Right Hand Wall Following</p>
        </div>
        <div class="col-lg-3 col-md-6 mb-5 mb-md-0">
          <span class="service-icon rounded-circle mx-auto mb-3">
        <a href="milestone3.html#Milestone3"><i class="icon-like"></i></a>
          </span>
          <h4><a href="milestone3.html#Milestone3" style="color: #FFFFFF">
		  <strong>Milestone 3</strong>
          </h4></a>
          <p class="text-faded mb-0">Robot Avoidance and Maze Exploration</p>
        </div>
        <div class="col-lg-3 col-md-6">
          <span class="service-icon rounded-circle mx-auto mb-3">
            <a href="lab4_milestone4.html#Milestone4"><i class="icon-mustache"></i></a>
          </span>
          <h4><a href="lab4_milestone4.html#Milestone4" style="color: #FFFFFF">
		  <strong>Milestone 4</strong>
          </h4></a>
          <p class="text-faded mb-0">Full Robot Integration</p>
        </div>
      </div>

    </div>
  </section>
	

  <!--Milestone 4 and Lab 4-->
  <section class="content-section bg-light" id="Milestone4">
    <div class="container">
      <div class="row text-center">
        <div class="col-lg-10 mx-auto">
          <h2>Lab 4 & Milestone 4: RF Communication and Full Robot Integration</h2>
          <div class="row">
          <div class="col-lg-3"> 
   
           </div>
          </div>
         
        </div>
      </div>

  <br/>
      
	    <div class="row">
        <div class="col-lg-10 mx-auto">
		<h3>Objectives</h3>
		<p style = "text-indent: 50px;">This is documentation is the combination of lab 4 and milestone 4. We want to be able to update the base station Arduino and draw out the maze on the monitor using FPGA. Additionally, we want to do the robot integration for the final competition. </p>
		<h3>Materials Used:</h3>
		<ul>
			<li>2 Arduino Uno</li>
			<li>2 Nordic nRF24L01+ transceivers</li>
			<li>2 radio breakout boards with headers</li>
			<li>Other sensors and parts from previous labs and milestones</li>
		</ul>
	<h3>RF Communication and  Data Scheme</h3>
		<p>1. In order to map out the map successfully, we need a base station Arduino to communicate with the Arduino on the robot to correctly map out the maze. We use the Nordic nRF24L01+ transceivers for RF communication between the two Arduinos. We need the robot’s x and y coordinates and the wall information. Since the maze is 9 by 9, we need 4 bits each for the x and y coordinates of the robots. We use 4 bits for wall information also, which correspond to the north, south, east, and west wall. 1 indicates that there is a wall and 0 indicates that there is no wall. The code below shows how we encode the data. </p>
<br>
		<img src="Pictures/data scheme.JPG">
		</br>
		    </br>
		<p>2. There is example code given for the RF communication. In order to get the RF communication working, we need to change the channels in which the two transceivers communicate. We need to find channels that are not used by other teams to minimize noise and interference. Using the equation posted on Canvas, we decided to use channel 19 and 20 for communication. We then modified the code in order to send the desired maze information that we need to map out the maze. In order to send data to the FPGA for displaying the maze on the monitor, we created an extra bit called new_data to indicate whether there was new data coming in. We had a variable called got_data on the base station Arduino. We checked the got_data with the prev_data, which was the previous value of got_data. If they were different, we would set new_data to high indicating for 20ms indicating that there were new data coming in. We then set new_data low so that the FPGA would not constantly updating even when there was no new data coming in.</p>
<br>
		
	    
		<!-- Trigger the modal with a button -->
<button type="button" class="btn btn-info btn-lg" data-toggle="modal" data-target="#myModal3">Base Station Code</button>
		<!-- Modal -->
<div id="myModal3" class="modal fade" role="dialog">
  <div class="modal-dialog">

    <!-- Modal content-->
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Base Station Code</h4>
      </div>
      <div class="modal-body">
	      <code > 
		<pre style="color: #b32789">
  
  if ( role == role_pong_back ){
  
    // if there is data ready
    if ( radio.available() ){
    
      // Dump the payloads until we've gotten everything
      unsigned int got_data1;
      bool done = false;
      int new_data = 0;
      while (!done){
      
        // Fetch the payload, and see if this was the last one.
        done = radio.read( &got_data1, sizeof(unsigned int) );
        
	// send to fpga
        if(prev_data != got_data1){
          new_data = 1;
	  delay(20);
	  new_data = 0;
        }
	else{
          new_data = 0;
        }
        digitalWrite(2,bitRead(got_data1,0));
        digitalWrite(3,bitRead(got_data1,1));
        digitalWrite(4,bitRead(got_data1,2));
        digitalWrite(19,bitRead(got_data1,3));
        digitalWrite(18,bitRead(got_data1,4));
        digitalWrite(17,bitRead(got_data1,5));
        digitalWrite(16,bitRead(got_data1,6));
        digitalWrite(15,bitRead(got_data1,7));
       	digitalWrite(5,bitRead(got_data1,8));
       	digitalWrite(6,bitRead(got_data1,9));
       	digitalWrite(7,bitRead(got_data1,10));
       	digitalWrite(8,bitRead(got_data1,11));
       	digitalWrite(14,new_data);
        prev_data = got_data1;
        delay(20);
        new_data = 0;
      }


		</pre>
		</code>	
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div>

  </div>
		    </div>
		    </br>
	  </br>

		<!-- Trigger the modal with a button -->
<button type="button" class="btn btn-info btn-lg" data-toggle="modal" data-target="#myModal1">Data Transmitting Code</button>
		<!-- Modal -->
<div id="myModal1" class="modal fade" role="dialog">
  <div class="modal-dialog">

    <!-- Modal content-->
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Data Transmitting Code</h4>
      </div>
      <div class="modal-body">
	      <code > 
		<pre style="color: #b32789">
void sendData(byte xCoord, byte yCoord, byte walls) {
  
  byte robot_loc = (xCoord << 4) | (yCoord);
  int data = robot_loc | (walls << 8);
  
  if (role == role_ping_out){
    // First, stop listening so we can talk.
    radio.stopListening();
    
    // Take the time, and send it.  This will block until complete
    unsigned int send_data1 = data; //WSEN,x,y
    bool ok = radio.write( &send_data1, sizeof(unsigned int) );
   
   // Now, continue listening
    radio.startListening();
    
    // Wait here until we get a response, or timeout (250ms)
    unsigned long started_waiting_at = millis();
    bool timeout = false;
   
   while ( ! radio.available() && ! timeout )
      if (millis() - started_waiting_at > 200 )
        timeout = true;
    // Describe the results
    if ( timeout ){
      printf("Failed, response timed out.\n\r");
    }
    else{
      
      // Grab the response, compare, and send to debugging spew
      unsigned int got_data1;
      radio.read( &got_data1, sizeof(unsigned int) );
    }
    delay(200);
  }



		</pre>
		</code>	
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div>

  </div>
		    </div>
		    </br>

           </div>
	   </div>
	    <br/>
	    <br/>	
	
	
      	
	<!--Base Station-->    
	    
    <div class="row">
        <div class="col-lg-10 mx-auto">
		<h3>Base Station </h3>
		<img src="Pictures/FPGA diagram.png">
		<p style = "text-indent: 50px;">Above is a diagram of the overall system of the base station. The base station RF receives data on the robot’s current position, and wall information. That data is output from the arduino and input into the GPIO of the FPGA through a voltage divider so the signal drops from 5V to 3.3V. Inside the FPGA, there are three modules: Image processor, M9K RAM, and the VGA Driver. Image Processor is what we’ve primarily worked on, while the M9K RAM and VGA driver were given to us. Image processor takes the data of the current position of the robot and the wall information and sends the write address and pixel color data to the M9K RAM. The RAM then stores this information in memory and outputs that data to VGA driver which translates the data to be correctly displayed  on the monitor through the VGA connector.</p>
		<h4>Image Processor </h4>
		<p>1. The requirements for image processor is to input the data from arduino and output x_addr and y_addr (these are the x and y coordinates on the screen for each pixel, not the position of the robot) that is used for calculating the write address for M9K RAM, the result which contains the color information for the pixel at that x and y address on the monitor, and the W_EN signal that indicates when the M9K ram writes.</p>
		<p>2. We decided the arduino_in signal to be total of 13 bits which consists of 4 bits of x position of the robot, 4 bits of y position of the robot, 4 bits for either wall is there or not (north, south, east, west), and one bit for the arduino to let the FPGA know when there is new data available.</p>
		<p>3. Our image processor has one big always loop that contains all code. This always block is executed at every clock, and while new data is high, using the wall information, it assigns colors to a temporary array called tile. This tile is reused for all the robot positions, and represents a single intersection, which gets displayed in 30 by 30 tile on the screen. When the tile is finished getting assigned colors, the update bit is set to high. While this update bit is high, x_addr, y_addr, result, and W_EN are set for output. When the entire tile gets written to its appropriate address, all the local variables get reset as well as the tile and the update bit. Notice that if new_data is still high at this point, the program will return to the tile color assignment code and repeat the entire process until new_data is low. Below is the overall structure for easier understanding.</p>
		
		<!-- Trigger the modal with a button -->
<button type="button" class="btn btn-info btn-lg" data-toggle="modal" data-target="#myModal2">FPGA Image ProcessorCode</button>
		<!-- Modal -->
<div id="myModal2" class="modal fade" role="dialog">
  <div class="modal-dialog">

    <!-- Modal content-->
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">FPGA Image Processor Code</h4>
      </div>
      <div class="modal-body">
	      <code > 
		<pre style="color: #b32789">
always @ (posedge CLK) begin
	if (new_data) begin
	 	<assign colors to tile>
		if(done assigning) begin
			update = 1;
		end
	end else begin
		update = 0;
	end
     if (update) begin
		<update x_addr, y_addr, result, and W_EN>
		<reset local variables and set update to low when done 
           writing entire tile>
	end
end
		</pre>
		</code>	
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div>

  </div>
		    </div>
		    </br>
	    </br>

	    <h3> Full Robot Integration</h3>
	    <h4>Override Button</h4>
	    <p>1. We implemented a working override button that would start the robot in case the robot did not detect the 950Hz note. Hardware wise, the pushbutton was placed on a breadboard with a wire connected to a digital pin. The digital pin read the ground signal (0) whenever the button was not pressed. When the button was pressed, the signal ran high and the robot would start. We implemented the override button inside the FFT function. We put the override button code in a while loop condition so that the robot will not start unless it hears the desired frequency or the push button is pressed.</p>
	    <img src="Pictures/override button.JPG">
	    <h4>Wall Sensors</h4>
	    <p>1. Our wall sensors worked consistently, and the robot correctly sent the wall information of the walls in the maze at each intersection. We needed to calibrate the wall sensors by placing the robot at an intersection (the robot only checked for walls when it sensed that it was at a possible turning point) and reading the analog values of each sensor. By doing this, we were able to find the suitable threshold values for wall detection. If the sensor read a value below this threshold, that meant that there was a wall that needed to be avoided. Having reliable wall sensors was essential because this information was crucial for both DFS traversing and mapping. The wall information affected the search algorithm greatly because it affected the robot’s ability to assess possible paths and open nodes. Additionally, FPGA needed accurate wall information for display. Therefore,  the wall  information had to be sensed, processed, and packaged out via radio in a reliable fashion.</p>
	    <h4>DFS Algorithm</h4>
	    <p>1. Our wall sensors worked consistently, and the robot correctly sent the wall information of the walls in the maze at each intersection. We needed to calibrate the wall sensors by placing the robot at an intersection (the robot only checked for walls when it sensed that it was at a possible turning point) and reading the analog values of each sensor. By doing this, we were able to find the suitable threshold values for wall detection. If the sensor read a value below this threshold, that meant that there was a wall that needed to be avoided. Having reliable wall sensors was essential because this information was crucial for both DFS traversing and mapping. The wall information affected the search algorithm greatly because it affected the robot’s ability to assess possible paths and open nodes. Additionally, FPGA needed accurate wall information for display. Therefore,  the wall  information had to be sensed, processed, and packaged out via radio in a reliable fashion.</p>
	    <p>2. We initially implemented DFS by storing the walls at each node and whether a node was visited or not in 2 separate 2-dimensional arrays. We also had separate stacks for backtrack and a global turn sequence to get back to the start node. This was very inefficient in terms of space, and it also ended up making things more complex, since we had all of these different moving components. The stacks we used were not a part of the Arduino Stack library, but were rather arrays with a global variable storing the index of the current element. </p>
	    <p>3. Because this whole system was very buggy and complicated, we moved to a far simpler and more effective implementation.</p>
	    <p>4. Our final DFS system had one 2-dimensional array of bytes, which contained the previous global direction that a node was entered (NSEW) and the cumulative directions that a node was entered at any point in the past. For example if we entered a node facing North, we would set the 4 leftmost bits and the 4 rightmost bits of the byte at the node to North, which was represented by 0001 -- this was 00010001 at that node. Then, let’s say after more exploration we returned to this same node facing West. We would override the 4 leftmost bits to West (1000) and combine the rightmost bits (1001) to make 10001001 (Note: storing cumulative previous directions was an attempt to optimize backtrack, which if we had more time we would have implemented to potentially cut down the number of nodes it needs to touch to actually backtrack). This allowed for us to get rid of the stack completely, which was very inconsistent in our implementation prior to this system.</p>
	    <p>5. When we reach a dead end (a node surrounded by walls or visited nodes), we set the inBacktrack global variable to true and enter backtrack mode. When in backtrack mode, at a particular node, the robot would read the previous direction of entry and go in the opposite direction. So if the robot entered a node facing the West and backtracks to the node facing South, it would turn left to go back the way it came. Also, when in backtrack mode, it does not override the previous direction of entry, so that when backtracking later, it will never go down a deadend or fully explored path again. </p>
	    <p>6. Our robot was done if there were no more available nodes left, which was represented by 255 (11111111) in unvisited, but accessible nodes. The robot would reach a node, and if the nodes in front, to the left, and/or to the right were not visited (if the node is still 0), and there were no walls blocking them, then it would set those nodes to 255. If there are no more nodes with 255, then we are done. The green light was set to HIGH, and the robot will backtrack to the starting point.</p>

	    <h4>Robot Avoidacne</h4>
	    <p>1. For robot avoidance, we had to consider multiple cases of when a robot could be seen. The simplest case is when we are exploring new nodes with DFS and we see a robot in front of us. Because the state of the robot in DFS is very essential to its exploration, we decided to initially just turn 360 degrees and check again if the robot was there. If the other robot detected us and went away, or if it just explored a different path, we would continue on our current path as if we hadn’t seen the robot. However, if we did the 360 turning and the robot was still there, we designed a system where the robot would enter “robotBacktrack”, which would backtrack until it found an open path and go down the next path. Ideally it would only go back 1 or 2 nodes. The reason why we had a separate backtrack is because we needed to set the node back to available, so that the robot would return to that path and finish exploring. Otherwise, that path would never be explored again.</p>
	    <p>2. The other case was if we see a robot in backtrack. This is a dangerous case because we do not want to turn around and go back to the dead end. We also would not want to reset the nodes to unvisited because we do not want to return to this already-explored path.</p>
	    <p>3. Unfortunately there were bugs with the robotBacktrack and due to time constraints, we decided to keep the 360 turn, but then just go back to the previous node and try to go down a different path. If there were no different paths that were able to be explored, our robot would just have to keep turning around and going back to the previous node until the other robot moved. However, we did not anticipate that this case would occur, and it did not occur during the competition. This also helped prioritize the importance of not re-exploring nodes, and not losing track of where the robot was.
</p>
	    <p>The video below shows our robot avoiding other robot in the maze. </p>
	    
<iframe width="362" height="644" src="https://www.youtube.com/embed/68yvvU5Cw-M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
	</br>
		</br>
	    <h3>Final Robot Design</h3>
	    <p style = "text-indent: 50px;">The pictures below show the final design of our robot, Clyde, and its cost list.</p>
	    <img src="Pictures/budget.JPG">
</br>
</br>
	    <img height = "600" width = "800" src="Pictures/Clyde.JPG">
</br>

				
		    
		    </div>

	    <div class="row">
        <div class="col-lg-10 mx-auto">
				    <h3>Conclusion</h3>
		    <p style = "text-indent: 50px;">After the final integration, Clyde, our robot was able to successfully traversed the maze using the DFS algorithm and map out the maze. The video below showed Clyde traversing a 9 by 9 maze and sending data to the base station Arduino to display on the monitor. The picture below shows the actual maze and the final display on the monitor.</p>
		</br>
		<img src="Pictures/Final Mapping.JPG">
		    </br>
				   <iframe width="644" height="362" src="https://www.youtube.com/embed/Fl9oKXuIaDU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
				    </br>
</br>
		    </br>

</div>
</div>
	    <div class="row">
        <div class="col-lg-10 mx-auto">
		</br>
	    <h4 style = "text-indent: 50px;"><em>Finally, special shout out to my roommate, who has helped out with our website and making the final video. Also, shout out to all the TAs who have helped us in labs!! Thank you and we wouldn't have made it through this class without your help!! :)</em></h4>
	    </div>
</div>
  </section>

  <!-- Callout -->
  <section class="callout">
    <div class="container text-center">
      <h2 class="mx-auto mb-5">Welcome to Our Website!</h2>
      <a class="btn btn-primary btn-xl" href="#">THANk YOU!!</a>
    </div>
	  
  </section>



  <!-- Call to Action -->
  <section class="content-section bg-primary text-white">
    <div class="container text-center">
      <h2 class="mb-4">The buttons below are impossible to resist...</h2>
      <a href="#" class="btn btn-xl btn-light mr-4">Click Me!</a>
      <a href="#" class="btn btn-xl btn-dark">Look at Me!</a>
    </div>
  </section>

 


  <!-- Footer -->
  <footer class="footer text-center">
    <div class="container">
      <ul class="list-inline mb-5">
        <li class="list-inline-item">
          <a class="social-link rounded-circle text-white mr-3" href="#">
            <i class="icon-social-facebook"></i>
          </a>
        </li>
        <li class="list-inline-item">
          <a class="social-link rounded-circle text-white mr-3" href="#">
            <i class="icon-social-twitter"></i>
          </a>
        </li>
        <li class="list-inline-item">
          <a class="social-link rounded-circle text-white" href="#">
            <i class="icon-social-github"></i>
          </a>
        </li>
      </ul>
      <p class="text-muted small mb-0">Copyright &copy; Start Bootstrap: Stylish Portfolio Theme</p>
    </div>
  </footer>

  <!-- Scroll to Top Button-->
  <a class="scroll-to-top rounded js-scroll-trigger" href="#page-top">
    <i class="fas fa-angle-up"></i>
  </a>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/stylish-portfolio.min.js"></script>

</body>

</html>
