<!DOCTYPE html>
<html lang="en">

<head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="">

  <title>ECE 3400 Team 2 Website</title>

  <!-- Bootstrap Core CSS -->
  <link href="vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom Fonts -->
  <link href="vendor/fontawesome-free/css/all.min.css" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:300,400,700,300italic,400italic,700italic" rel="stylesheet" type="text/css">
  <link href="vendor/simple-line-icons/css/simple-line-icons.css" rel="stylesheet">

  <!-- Custom CSS -->
  <link href="css/stylish-portfolio.min.css" rel="stylesheet">

</head>

<body id="page-top">

  <!-- Navigation -->
  <a class="menu-toggle rounded" href="#">
    <i class="fas fa-bars"></i>
  </a>
  <nav id="sidebar-wrapper">
    <ul class="sidebar-nav">
      <li class="sidebar-brand">
        <a class="js-scroll-trigger" href="#">Team 2</a>
      </li>
      <li class="sidebar-nav-item">
        <a class="js-scroll-trigger" href="index.html">Home</a>
      </li>
      <li class="sidebar-nav-item">
        <a class="js-scroll-trigger" href="index.html#Team">Team Members</a>
      </li>
 	<li class="sidebar-nav-item">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> <span class="nav-label">Labs</span><span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        <li><a style="color: #1D809F" href="lab1.html#Lab1">Lab 1</a></li>
                        <li><a style="color: #1D809F" href="lab2.html#Lab2">Lab 2</a></li>
                        <li><a style="color: #1D809F" href="lab3.html#Lab3">Lab 3</a></li>
                        <li><a style="color: #1D809F" href="lab4_milestone4.html#Milestone4">Lab 4</a></li>
                    </ul>
                </li>
	<li class="sidebar-nav-item">
                    <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false"> <span class="nav-label">Milestones</span><span class="caret"></span></a>
                    <ul class="dropdown-menu">
                        <li><a style="color: #1D809F" href="milestones.html#Milestone1">Milestone 1</a></li>
                        <li><a style="color: #1D809F" href="milestone2.html#Milestone2">Milestone 2</a></li>
                        <li><a style="color: #1D809F" href="milestone3.html#Milestone3">Milestone 3</a></li>
                        <li><a style="color: #1D809F" href="lab4_milestone4.html#Milestone4">Milestone 4</a></li>
                    </ul>
                </li>
      <li class="sidebar-nav-item">
        <a class="js-scroll-trigger" href="TEAM CONTRACT.pdf">Team Contract</a>
      </li>
    </ul>
  </nav>

  <!-- Header -->
  <header class="masthead d-flex">
    <div class="container text-center my-auto">
      <h1 class=class="mb-1" style="color: white; text-shadow: 2px 2px 5px black;text-indent: 100px;">Milestones</h1>
      <h3 class=class="mb-1" style="color: white; text-shadow: 2px 2px 5px black;text-indent: 100px;">
        <em> What We Have Accomplished </em>
      </h3>
      <a class="btn btn-primary btn-xl js-scroll-trigger" style="margin-left: 100px"  href="#Labs">Start</a>
    </div>
    <div class="overlay"></div>
  </header>

  <!-- Milestone -->
	<!--part1 Robot Avoidance -->  
  <section class="content-section bg-primary text-white text-center" id="Labs">
    <div class="container">
      <div class="content-section-heading">
        <h3 class="text-secondary mb-0">Milestones</h3>
        <h2 class="mb-5">What We Have Accomplished</h2>
      </div>
      <div class="row">
        <div class="col-lg-3 col-md-6 mb-5 mb-lg-0">
          <span class="service-icon rounded-circle mx-auto mb-3">
   	<a href="milestones.html#Milestone1"><i class="icon-screen-smartphone"></i></a>
          </span>
          <h4><a href="milestones.html#Milestone1" style="color: #FFFFFF">
	<strong  >Milestone 1</strong>
		  </h4></a>
          <p class="text-faded mb-0">Line Following and Figure Eight</p>

        </div>
        <div class="col-lg-3 col-md-6 mb-5 mb-lg-0">
          <span class="service-icon rounded-circle mx-auto mb-3">
          <a href="milestone2.html#Milestone2"><i class="icon-pencil"></i></a>
          </span>
          <h4><a href="milestone2.html#Milestone2" style="color: #FFFFFF">
            <strong  >Milestone 2</strong>
          </h4></a>
          <p class="text-faded mb-0">Right Hand Wall Following</p>
        </div>
        <div class="col-lg-3 col-md-6 mb-5 mb-md-0">
          <span class="service-icon rounded-circle mx-auto mb-3">
        <a href="milestone3.html#Milestone3"><i class="icon-like"></i></a>
          </span>
          <h4><a href="milestone3.html#Milestone3" style="color: #FFFFFF">
		  <strong>Milestone 3</strong>
          </h4></a>
          <p class="text-faded mb-0">Robot Avoidance and Maze Exploration</p>
        </div>
        <div class="col-lg-3 col-md-6">
          <span class="service-icon rounded-circle mx-auto mb-3">
            <a href="milestone4.html#Milestone4"><i class="icon-mustache"></i></a>
          </span>
          <h4><a href="milestone4.html#Milestone4" style="color: #FFFFFF">
		  <strong>Milestone 4</strong>
          </h4></a>
          <p class="text-faded mb-0">Full Robot Integration</p>
        </div>
      </div>

    </div>
  </section>
	

  <!--Milestone 3-->
  <section class="content-section bg-light" id="Milestone3">
    <div class="container">
      <div class="row text-center">
        <div class="col-lg-10 mx-auto">
          <h2>Milestone 3 Robot Avoidance and Maze Exploration</h2>
          <div class="row">
          <div class="col-lg-3"> 
   
           </div>
          </div>
         
        </div>
      </div>

  <br/>
      
	    <div class="row">
        <div class="col-lg-10 mx-auto">
		<h3>Objectives</h3>
		<p style = "text-indent: 50px;">For Milestone 3, we want the robot to be able to explore the maze using some algorithms. We also add in the robot detection feature so that our robot will turn around when it sees other robots, avoiding crashes. </p>
		<ul>Materials Used:
			<li>1 Arduino Uno</li>
			<li>1 USB A/B Cable</li>
			<li>4 IR Emitters</li>
			<li>1 IR Receiver</li>
			<li>Variuos Resistors</li>
			<li>1 Solderless breadboard</li>
		</ul>
		<h3>Robot Avoidance</h3>
		
		<p>1. Milestone 2 required that the robot be able to perform right-hand following around an arbitrary set of walls. In order to accomplish Milestone 3, we had to add a wall sensor to the left of the robot. We also added IR emitters and receiver for robot detection purposes. Basically, we want to sense any robots within a foot in front of us, and we want to react to it to avoid crashes. </p>
	<br>
		<p>2. The robot avoidance involved placing a 940nm emitter on each side of the robot (so 4 in total) and placing an IR receiver on the front. The 940nm emitter is to signal other robots of our existence, and the IR sensor on the front is to sense IR signal emitted from other robots. The IR sensor on the front is connected to an analog pin on the Arduino. </p>
<br>
		<p>3. The logic and sensing are based on a series of threshold values. The threshold value is the point at which a nearby robot should be sensed (i.e. if the sensor reads a value less than X, this means that the robot is within the 1-foot range).  Here are the pictures of the robot with all the required aspects of Milestone 3 included.</p>
</br>
	<!-- insert two pictures of the bot here-->
		    </br>
	    </br>
	  </br>
   <div class="row">
          <div class="col-lg-6" > 
      <img width="600" height="400"  style="transform:rotate(90deg);" src="Pictures/robot3.png"/>       
            </div>
          <div class="col-lg-6"> 
            <img width="600" height="400" style="transform:rotate(90deg);" src="Pictures/robot1.png"/>
            </div>
          </div>
		
	</br>
	</br>
</br>
</br>
</br>
		<p>4. In order to find a threshold value (the value below which we knew there was a robot closeby), we hooked up an IR emitter to a battery-powered circuit. We found that when another robot was less than 2 squares away, the IR receiver showed an analog value less than 700. Therefore we chose the IR threshold value to be 700. Here is our code for using the IR sensor to detect other robots. </p>
		    </br>
	<!-- Trigger the modal with a button -->
<button type="button" class="btn btn-info btn-lg" data-toggle="modal" data-target="#myModal3">Robot Detection Code</button>
		<!-- Modal -->
<div id="myModal3" class="modal fade" role="dialog">
  <div class="modal-dialog">

    <!-- Modal content-->
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">Robot Detection Code</h4>
      </div>
      <div class="modal-body">
	      <code > 
		<pre style="color: #b32789">
#include &lt;Servo.h&gt;
//initiates the pins for sensors
#define wallSensorFront A2 		// Sharp IR GP2Y0A41SK0F (4-30cm, analog)
#define wallSensorRight A5
#define wallSensorLeft A1
#define irSensorFront A3        	//Readings from IR sensor to analog pin

int llinesen = 5; 			//line sensor on the left
int rlinesen = 4; 			//line sensor on the right
int rWheelPin = 10; 			//right wheel
int lWheelPin = 9; 			//left wheel
int blueLed = 11; 			// Indicates robot sensed
int redLed = 8; 			// Indicated wall sensed  
               
//thresholds
int irThresh=700;            		//Other Robot Distance
int lineThresh = 750;           	//Line Sensor
float distThresh_f = 5;         	//Forward Wall
int distThresh_r = 7;          		//Right Wall
int distThresh_l = 11;          	//Left Wall


Code for IR Sense
void irSense() {
  int val=analogRead(irSensorFront);  	//variable to store values from the photodiode  
   if(val <= irThresh) {          	//If obstacle is nearer than the Threshold range    
   digitalWrite(blueLed,HIGH);		// turn blue LED on, another robot is in front of Gerald
  //turn around
  rWheel.write(180);
  lWheel.write(180);
  delay(1500);
  }  
  //If obstacle is not in Threshold range 
  else{         
   digitalWrite(blueLed,LOW);     	// turn blue LED off
   //Do nothing - continue as you were
  }  
}

		</pre>
		</code>	
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div>

  </div>
		    </div>
		    </br>
	    </br>
	  </br>
		<p>5. We calibrated all the sensors to detect walls and robots at the appropriate distances. In order to show what the robot was “seeing,” we added LEDs. The red LED lights up when the robot sees a wall on any side, while the blue LED lights up when it sees a robot in front of it. This is meant to demonstrate that the robot knows what it is seeing around it and is processing that information accordingly. Here is a video showing our robot traversing through a maze and turning around to avoid a robot in front of it.</p>
		    
	    	   <div class="row">
        <div class="col-lg-10 mx-auto">
			 <video width ="640" height ="360" controls>

			    <source src = "Videos/robot avoidance.mp4" type = "video/mp4">

				    Your Browser does not support the video tag.
				    </video>   
				  </div>
		   </div>	    



           </div>
	   </div>
	    <br/>
	    <br/>

      	
	<!--part2 Maze Exploration-->    
	    
    <div class="row">
        <div class="col-lg-10 mx-auto">
		<h3>Maze Exploration</h3>
		<p>1. There are different algorithms that we could have used for maze exploration, such as BFS, DFS, A*, etc. We ended up choosing to use DFS because we felt that later on when we optimize, we may be able to map adjacent nodes just by using our sensors. This would cut out the time that it takes to physically move the robot to that node and map it there. Additionally, DFS and BFS work better on different types of maps, and since the map configurations are random, it is impossible to know which will do better on the day of the competition. If we are able to map more than one node at a given location in the end, then DFS will play a crucial role in our optimization. Regardless, we would need to store which nodes have been visited. Later on, we may combine the two, or slightly modify our current implementation of DFS to optimize memory storage, since we are running low on storage. </p>
		<p>2. Depth First Search is a searching algorithm that traverses a graph. It starts from one root node and goes as far as possible along each branch, mapping its children first, before backtracking and exploring nodes of the same depth and their children. Because the maze is a graph and not a tree, we had to store the visited states because graphs can contain cycles, and without knowing the visited nodes, we could infinitely search the maze. We call the DFS function as our search method in the line follow function when it reaches an intersection.</p>
		<p>3. To implement DFS in Arduino, we had a matrix that stored the current location and orientation of the robot, the walls that are present around it, as well as whether a node was visited. We did this by using a bit and having global directions NORTH = 1, EAST  = 2, SOUTH = 4,WEST  = 8, so when combined using an or statement, the resulting bit can encode uniquely what combination of walls are around the node. For example, 9 would mean walls are to the North and West of the node. </p>
		<p>4. We also had an array that stored the turn history of the robot and a global stack pointer that we incremented and decremented when we added or “popped” a direction (*Note: in reality we just returned the direction at the stack index and moved the stack index, we did not actually use the Stack data structure in Arduino). We added the opposite turn of the current turn to the array at the stack pointer so that when it was backtracking, it turned in the correct direction. </p>
		<p>5. The most difficult part was by far backtracking, which was called upon reaching a deadend. A dead end is a node with all walls or visited states surrounding it. To backtrack, we had to “pop” directions and follow the directions until there was an open, unvisited state. We then had to go to the unvisited state and update the direction at that junction so that the robot would not follow the same deadend path again. We would then continue adding the directions to the array until we reached another deadend, and backtracked again until, finally, we reached the original state, and the robot lit up the green LED.</p>
		<p>6. Below is our DFS implementation.</p>
		    
<!-- Trigger the modal with a button -->
<button type="button" class="btn btn-info btn-lg" data-toggle="modal" data-target="#myModal4">DFS Algorithm</button>

<!-- Modal -->
<div id="myModal4" class="modal fade" role="dialog">
  <div class="modal-dialog">

    <!-- Modal content-->
    <div class="modal-content">
      <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal">&times;</button>
        <h4 class="modal-title">DFS Algorithm</h4>
      </div>
      <div class="modal-body">
	      <p> This is the part where we control the on/off of the green LED.</p>
		<code > 
		<pre style="color: #b32789">

//Direction and turn types:
typedef enum {NORTH = 1,EAST  = 2,SOUTH = 4,WEST  = 8,} DIRECTION;
typedef enum {FORWARD = 1,LEFT  = 2,RIGHT = 4,BACK = 8,  } TURN;

//Stack and Maze representations:
byte turnStack[81];
byte maze[9][9] =  {  {0,0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0,0},
                       {0,0,0,0,0,0,0,0,0}};

bool validMove(int xCoord, int yCoord) {
  return !(xCoord > 8) && !(xCoord<0) && !(yCoord > 8) && !(yCoord<0);
}

//DFS algorithm
void dfs_traverse() {
    neighbourIndex();   
    updateWalls();

    if (!isFrontWall() && ((maze[yfront][xfront] == 0 && validMove(xfront, yfront)))) {
      moveForward();      
      if (maze[robotY][robotX] ==0) {turnStack[stackIndex] = FORWARD;} 
      robotX = xfront;
      robotY = yfront;
      stackIndex++;
    } 
    else if (!isLeftWall() && ((maze[yleft][xleft] == 0 && validMove(xleft, yleft)))) {
      if (maze[robotY][robotX] ==0) {turnStack[stackIndex] = RIGHT;}
      turnLeft();
      stackIndex++;
    } 
    else if (!isRightWall() && maze[yright][xright] == 0 && validMove(xright, yright)) {
      if (maze[robotY][robotX] == 0) {turnStack[stackIndex] = LEFT;}
      turnRight();
      stackIndex++;
    } 
    else {
      turnAround();
      neighbourIndex();
      backtrack();
    }
  }

//Updating maze state
void updateWalls() {
  maze[robotY][robotX] = wallCheck();
  return;
}
byte wallCheck() {
  byte wall = 0;
  
  switch (robotOrientation) {
    case(NORTH):
      if(isFrontWall()){  wall |= NORTH;}
      if(isLeftWall()) {  wall |= WEST; }
      if(isRightWall()){  wall |= EAST; }
      break;
    case(EAST):
      if(isFrontWall()){  wall |= EAST; }
      if(isLeftWall()) {  wall |= NORTH;}
      if(isRightWall()){  wall |= SOUTH;} 
      break;
    case (SOUTH):
      if(isFrontWall()){  wall |= SOUTH;}
      if(isLeftWall()) {  wall |= EAST; }
      if(isRightWall()){  wall |= WEST; } 
      break;
    case (WEST):
      if(isFrontWall()){  wall |= WEST; }
      if(isLeftWall()) {  wall |= SOUTH;}
      if(isRightWall()){  wall |= NORTH;} 
      break;
  }
  if(wall == 0) { wall = 15; }
  return wall;  
}

//Backtrack:
void backtrack(){
  while (true) {
    if (isLeftWhite() && (!isRightWhite())){         	// if robot is off to the right
      rWheel.write(85);
      lWheel.write(85);
      delay(100);
    }
  else if ((!isLeftWhite()) && isRightWhite()){   	// if robot is off to the left
    rWheel.write(95);
    lWheel.write(95);
    delay(100);
  } 
  else if (isLeftWhite() && isRightWhite()){    
    if (!((isLeftWall() || maze[yleft][xleft]>0) && (isRightWall() || maze[yright][xright]>0) 
        && (isFrontWall()|| maze[yfront][xfront]>0))) { updateTurnStack(); break;}
    byte dir = stack_pop();
    switch (dir){
      case FORWARD:
        moveForward();
        robotX = xfront;
        robotY = yfront;
        neighbourIndex();
        break;
      case RIGHT:
        turnRight();
        neighbourIndex();
        break;
      case LEFT:
        turnLeft();
        neighbourIndex();
        break;
      default: break;
    }
    moveForward();
  }  else {    
    moveForward(); }
}
  return;
}

void updateTurnStack() {
    switch(turnStack[stackIndex-1]) {
      case LEFT:
        turnStack[stackIndex-1] = RIGHT;
        break;
      case RIGHT:
        turnStack[stackIndex-1] = LEFT;
        break;
      default:
        break;
    } 
}

byte stack_pop() {
  if (stackIndex != 0) {
    stackIndex--;
    byte b = turnStack[stackIndex];
    while(b == BACK){
      stackIndex--;
      b = turnStack[stackIndex];
    }
    return b;
  }
}

Updating robot orientation:
void orientRight(){
  switch (robotOrientation) {
  case NORTH: robotOrientation = EAST;  break;
  case EAST:  robotOrientation = SOUTH; break;
  case SOUTH: robotOrientation = WEST;  break;
  case WEST:  robotOrientation = NORTH; break;
 }
}
void orientLeft(){
  switch(robotOrientation){
  case NORTH: robotOrientation = WEST;  break;
  case WEST:  robotOrientation = SOUTH; break;
  case SOUTH: robotOrientation = EAST;  break;
  case EAST:  robotOrientation = NORTH; break;
 }
}
void neighbourIndex(){
  switch(robotOrientation){
    case NORTH:           
       xleft=robotX-1; 
       yleft=robotY;
       xfront=robotX;
       yfront=robotY-1;
       xright=robotX+1;
       yright=robotY;
       xback=robotX;
       yback=robotY+1;
      break;
    case EAST:           
       xleft=robotX;
       yleft=robotY-1;
       xfront=robotX+1;
       yfront=robotY;
       xright=robotX;
       yright=robotY+1;
       xback=robotX-1;
       yback=robotY;
      break; 
    case SOUTH:           
       xleft=robotX+1;
       yleft=robotY;
       xfront=robotX;
       yfront=robotY+1;
       xright=robotX-1;
       yright=robotY;
       xback=robotX;
       yback=robotY-1;
      break;
    case WEST:            
       xleft=robotX;
       yleft=robotY+1;
       xfront=robotX-1;
       yfront=robotY;
       xright=robotX;
       yright=robotY-1;
       xback=robotX+1;
       yback=robotY;
      break;
 }
}


</pre>
		</code>	
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
      </div>
    </div>
  </div>
		    </div>
		    </br>
	</br>
		</br>
	    <p>7. We then ran our robots in three different maze configurations. The first one was a small maze without any walls; the second one was a 4 by 5 maze without any dead ends; the last one was a 4 by 5 maze with two dead ends. The videos below show our robot successfully traversing three mazes using DFS.</p>
	    	    	   <div class="row">
        <div class="col-lg-10 mx-auto">
		<p>Robot was traversing a small maze without any walls inside. </p>
			 <video width ="360" height ="640" controls>

			    <source src = "Videos/dfs3.mp4" type = "video/mp4">

				    Your Browser does not support the video tag.
				    </video>   
				  </div>
		   </div>
	    	    	   <div class="row">
        <div class="col-lg-10 mx-auto">
		<p>Robot was traversing a 4*5 maze without any dead end. </p>
			 <video width ="640" height ="360" controls>

			    <source src = "Videos/dfs1.mp4" type = "video/mp4">

				    Your Browser does not support the video tag.
				    </video>   
				  </div>
		   </div>
	    
	  <div class="row">
        <div class="col-lg-10 mx-auto">
		<p>Robot was traversing a 4*5 maze without dead ends. </p>
			 <video width ="360" height ="640" controls>

			    <source src = "Videos/dfs2.mp4" type = "video/mp4">

				    Your Browser does not support the video tag.
				    </video>   
				  </div>
		   </div>

           </div>
          </div>
	    <br/>
	    <br/>



    </div>			 
  </section>

  <!-- Callout -->
  <section class="callout">
    <div class="container text-center">
      <h2 class="mx-auto mb-5">Welcome to
        <em>our</em>
        website!</h2>
      <a class="btn btn-primary btn-xl" href="#">Github Link</a>
    </div>
  </section>



  <!-- Call to Action -->
  <section class="content-section bg-primary text-white">
    <div class="container text-center">
      <h2 class="mb-4">The buttons below are impossible to resist...</h2>
      <a href="#" class="btn btn-xl btn-light mr-4">Click Me!</a>
      <a href="#" class="btn btn-xl btn-dark">Look at Me!</a>
    </div>
  </section>

 


  <!-- Footer -->
  <footer class="footer text-center">
    <div class="container">
      <ul class="list-inline mb-5">
        <li class="list-inline-item">
          <a class="social-link rounded-circle text-white mr-3" href="#">
            <i class="icon-social-facebook"></i>
          </a>
        </li>
        <li class="list-inline-item">
          <a class="social-link rounded-circle text-white mr-3" href="#">
            <i class="icon-social-twitter"></i>
          </a>
        </li>
        <li class="list-inline-item">
          <a class="social-link rounded-circle text-white" href="#">
            <i class="icon-social-github"></i>
          </a>
        </li>
      </ul>
      <p class="text-muted small mb-0">Copyright &copy; Start Bootstrap: Stylish Portfolio Theme</p>
    </div>
  </footer>

  <!-- Scroll to Top Button-->
  <a class="scroll-to-top rounded js-scroll-trigger" href="#page-top">
    <i class="fas fa-angle-up"></i>
  </a>

  <!-- Bootstrap core JavaScript -->
  <script src="vendor/jquery/jquery.min.js"></script>
  <script src="vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="js/stylish-portfolio.min.js"></script>

</body>

</html>
